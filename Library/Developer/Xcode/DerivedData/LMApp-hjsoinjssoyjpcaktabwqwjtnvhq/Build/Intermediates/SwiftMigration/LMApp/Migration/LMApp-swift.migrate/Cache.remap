[
 {
  "file": "/Volumes/KINGSTON/LockheedMartin 2/Lockheed%20Martin/Cache.swift",
  "offset": 1992,
  "remove": 6226,
  "text": "do {\n\t\t\t\ttry fileManager.createDirectoryAtPath(cacheDirectory, withIntermediateDirectories: true, attributes: nil)\n\t\t\t} catch _ {\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t *  @param name\t\tName of this cache\n\t *\n\t *  @return\t\t\tA new cache with the given name and the default cache directory\n\t */\n\tpublic convenience init(name: String) {\n\t\tself.init(name: name, directory: nil)\n\t}\n\t\n\t\n\t// MARK: Awesome caching\n\t\n\t/**\n\t *  Returns a cached object immediately or evaluates a cacheBlock. The cacheBlock will not be re-evaluated until the object is expired or manually deleted.\n\t *\n\t *  If the cache already contains an object, the completion block is called with the cached object immediately.\n\t *\n\t *\tIf no object is found or the cached object is already expired, the `cacheBlock` is called.\n\t *\tYou might perform any tasks (e.g. network calls) within this block. Upon completion of these tasks, make sure to call the `success` or `failure` block that is passed to the `cacheBlock`.\n\t *  The completion block is invoked as soon as the cacheBlock is finished and the object is cached.\n\t *\n\t *  @param key\t\t\tThe key to lookup the cached object\n\t *  @param cacheBlock\tThis block gets called if there is no cached object or the cached object is already expired.\n\t *\t\t\t\t\t\tThe supplied success or failure blocks must be called upon completion.\n\t *\t\t\t\t\t\tIf the error block is called, the object is not cached and the completion block is invoked with this error.\n\t *  @param completion\tCalled as soon as a cached object is available to use. The second parameter is true if the object was already cached.\n\t */\n\tpublic func setObjectForKey(key: String, cacheBlock: ((T, CacheExpiry) -> (), (NSError?) -> ()) -> (), completion: (T?, Bool, NSError?) -> ()) {\n\t\tif let object = objectForKey(key) {\n\t\t\tcompletion(object, true, nil)\n\t\t} else {\n\t\t\tlet successBlock: (T, CacheExpiry) -> () = { (obj, expires) in\n\t\t\t\tself.setObject(obj, forKey: key, expires: expires)\n\t\t\t\tcompletion(obj, false, nil)\n\t\t\t}\n\t\t\t\n\t\t\tlet failureBlock: (NSError?) -> () = { (error) in\n\t\t\t\tcompletion(nil, false, error)\n\t\t\t}\n\t\t\t\n\t\t\tcacheBlock(successBlock, failureBlock)\n\t\t}\n\t}\n\t\n\t\n\t// MARK: Get object\n\t\n\t/**\n\t *  Looks up and returns an object with the specified name if it exists.\n\t *  If an object is already expired, it is automatically deleted and `nil` will be returned.\n\t *  \n\t *  @param name\t\tThe name of the object that should be returned\n\t *  @return\t\t\tThe cached object for the given name, or nil\n\t */\n\tpublic func objectForKey(key: String) -> T? {\n\t\tvar possibleObject: CacheObject?\n\t\t\t\t\n\t\t// Check if object exists in local cache\n\t\tpossibleObject = cache.objectForKey(key) as? CacheObject\n\t\t\n\t\tif possibleObject == nil {\n\t\t\t// Try to load object from disk (synchronously)\n\t\t\tdispatch_sync(diskQueue) {\n\t\t\t\tlet path = self.pathForKey(key)\n\t\t\t\tif self.fileManager.fileExistsAtPath(path) {\n\t\t\t\t\tpossibleObject = NSKeyedUnarchiver.unarchiveObjectWithFile(path) as? CacheObject\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check if object is not already expired and return\n\t\t// Delete object if expired\n\t\tif let object = possibleObject {\n\t\t\tif !object.isExpired() {\n\t\t\t\treturn object.value as? T\n\t\t\t} else {\n\t\t\t\tremoveObjectForKey(key)\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn nil\n\t}\n\t\n\t\n\t// MARK: Set object\n\t\n\t/**\n\t *  Adds a given object to the cache.\n\t *\n\t *  @param object\tThe object that should be cached\n\t *  @param forKey\tA key that represents this object in the cache\n\t */\n\tpublic func setObject(object: T, forKey key: String) {\n\t\tself.setObject(object, forKey: key, expires: .Never)\n\t}\n\t\n\t/**\n\t *  Adds a given object to the cache.\n\t *  The object is automatically marked as expired as soon as its expiry date is reached.\n\t *\n\t *  @param object\tThe object that should be cached\n\t *  @param forKey\tA key that represents this object in the cache\n\t */\n\tpublic func setObject(object: T, forKey key: String, expires: CacheExpiry) {\n\t\tlet expiryDate = expiryDateForCacheExpiry(expires)\n\t\tlet cacheObject = CacheObject(value: object, expiryDate: expiryDate)\n\t\t\n\t\t// Set object in local cache\n\t\tcache.setObject(cacheObject, forKey: key)\n\t\t\n\t\t// Write object to disk (asyncronously)\n\t\tdispatch_async(diskQueue) {\n\t\t\tlet path = self.pathForKey(key)\n\t\t\tNSKeyedArchiver.archiveRootObject(cacheObject, toFile: path)\n\t\t}\n\t}\n\t\n\t\n\t// MARK: Remove objects\n\t\n\t/** \n\t *  Removes an object from the cache.\n\t *  \n\t *  @param key\tThe key of the object that should be removed\n\t */\n\tpublic func removeObjectForKey(key: String) {\n\t\tcache.removeObjectForKey(key)\n\t\t\n\t\tdispatch_async(diskQueue) {\n\t\t\tlet path = self.pathForKey(key)\n\t\t\tdo {\n\t\t\t\ttry self.fileManager.removeItemAtPath(path)\n\t\t\t} catch _ {\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t *  Removes all objects from the cache.\n\t */\n\tpublic func removeAllObjects() {\n\t\tcache.removeAllObjects()\n\t\t\n\t\tdispatch_async(diskQueue) {\n\t\t\tlet paths = (try! self.fileManager.contentsOfDirectoryAtPath(self.cacheDirectory)) \n\t\t\tlet keys = paths.map { $0.stringByDeletingPathExtension }\n\t\t\t\n\t\t\tfor key in keys {\n\t\t\t\tlet path = self.pathForKey(key)\n\t\t\t\tdo {\n\t\t\t\t\ttry self.fileManager.removeItemAtPath(path)\n\t\t\t\t} catch _ {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// MARK: Remove Expired Objects\n\t\n\t/**\n\t *  Removes all expired objects from the cache.\n\t */\n\tpublic func removeExpiredObjects() {\n\t\tdispatch_async(diskQueue) {\n\t\t\tlet paths = (try! self.fileManager.contentsOfDirectoryAtPath(self.cacheDirectory)) \n\t\t\tlet keys = paths.map { $0.stringByDeletingPathExtension }\n\t\t\t\n\t\t\tfor key in keys {\n\t\t\t\t// `objectForKey:` deletes the object if it is expired\n\t\t\t\tself.objectForKey(key)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// MARK: Subscripting\n\t\n\tpublic subscript(key: String) -> T? {\n\t\tget {\n\t\t\treturn objectForKey(key)\n\t\t}\n\t\tset(newValue) {\n\t\t\tif let value = newValue {\n\t\t\t\tsetObject(value, forKey: key)\n\t\t\t} else {\n\t\t\t\tremoveObjectForKey(key)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// MARK: Private Helper\n\t\n\tprivate func pathForKey(key: String) -> String {\n\t\treturn cacheDirectory.stringByAppendingPathComponent(key).stringByAppendingPathExtension(\"cache\")!\n\t}\n\n\tprivate func expiryDateForCacheExpiry(expiry: CacheExpiry) -> NSDate {\n\t\tswitch expiry {\n\t\tcase .Never:\n\t\t\treturn NSDate.distantFuture() ",
 }
]
